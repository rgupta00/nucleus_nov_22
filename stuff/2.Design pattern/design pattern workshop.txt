
Deep Dive design pattern with java
-----------------------------------
	=> Understanding abs, encapsulation
	=> When to go for interface, when to go for abstract class?
	=> What and Why design pattern
	=> loose coupling and high cohesion, using interface, 
	composition, aggrigation, inheritance, basic of uml
 
	=> Design Principles (SOLID)

	=> GOF Pattern categories

	=>selected design pattern

	
	=> Creational Patterns
		Singleton
		Factory
		Abstract Factory
		Builder
		Prototype

	=> Structural Patterns
		Adapter
		Decorator
		Facade Pattern
		Bridge
		Composite
		Flyweight
		Proxy

	=> Behavioral Patterns
		Chain of Responsibility
		Command
		Interpreter
		Iterator
		Mediator
		Memento
		Observer
		Strategy
		Template Method


	



Understanding Abstraction & encapsulation:
------------------------------------------

 class Cat {
	private String regId;
	private String ownerName;
	private int numberOfBonesFractured;
	private String deseaseHistory;
	private	double consultancyFee;
	
	String name;
	String favouriteFood;
	Date dob;	
}


Understanding Abstraction:
----------------------

Need of Method abst:
---------------------
class StackImpUsingArray {
	private int x[];
	private final int SIZE;
	private int top;
	
	public StackImpUsingArray(int size) {
		this.SIZE=size;
		top=-1;
		
	}
	
	
	public void push(int element){
		if(top>=SIZE)
			return ;
		else
			x[top++]=element;
	}
	
	
	public int pop(){
		if(top==-1)
			return -99;
		else
			return x[top--];
	}
}




 When to go for interface, when to go for abstract class?
------------------------------------------------------------

=> interface break the hierarchy
-------------------------------------------------

		Rotate
		|
         ----------------------------
         |                |
	Top		Tyre
	

class Top{
	public void play(){
		System.out.println("kids play top and enjoy....");
	}
}

class Tyre{
	public void move(){
		System.out.println("Tyre move vehical...");
	}
}






interface Rotatable{
	public void rotate();
}



=> interface improve oo design
------------------------------

class Bird{
	void sound(){
		System.out.println("bird sound");
	}
	void swimm(){
		System.out.println("default swimming.....");
	}
	void fly(){
		System.out.println("Default flying....");
	}
}

class Eagle extends Bird{
	
}

class Emu extends Bird{
	
}

class Duck extends Bird{
	
}


composition, aggrigation, inheritance
--------------------------------------
relationship bw the objects:-

IS-A
HAS-A
USE-A

FAVOUR COMPOSITION OVER INHERITANCE? WHAT ITS MEAN?


loose coupling and high cohesion,design as per interface
-------------------------------------------------

	Simple case study!

	"A passanger is using metro to travel from Laxmi Nagar to Noida"




class Metro{
	public void move(String source, String desination){
		System.out.println("moving from " + source+ " to " + desination);
	}
}

class Passanger{
	private String passangerName;
	public Passanger(String passangerName) {
		this.passangerName = passangerName;
	}


	public void travel(Metro metro,String source, String desination ){
		System.out.println("Passanger name: "+ passangerName);
		metro.move(source, desination);
	}
}
public class Demo {
	public static void main(String[] args) {
		
		Metro metro=new Metro();
		Passanger passanger=new Passanger("amit");
		passanger.travel(metro, "Laxmi nagar", "noida");
	}

}


favour composition over inheritance
-----------------------------------
	=> square rectangle liskov java

class Rectangle{
	private int l, b;

	public int getL() {
		return l;
	}

	public void setL(int l) {
		this.l = l;
	}

	public int getB() {
		return b;
	}

	public void setB(int b) {
		this.b = b;
	}

	public Rectangle(int l, int b) {
		this.l = l;
		this.b = b;
	}
	
	public int calculateArea(){
		return l*b;
	}
	
}

class Square extends Rectangle{
	public Square(int l){
		super(l, l);
	}
}


What and Why design pattern
-------------------------

	=> tried and tested solutions to work with

	=> language neutral and so can be applied to any OO language

	=>proven track record as they are already widely used and thus reduce 
	the technical risk to the project

	=>highly flexible and can be used in practically 
		any type of application or domain










Design Principles (SOLID)
---------------------------

        Single Responsibility Principle
	Open Close Principle
	Liskov's Substitution Principle
	Dependency Inversion Principle
	Interface Segregation Principle
	


Understanding SRP
-------------------
class Book {
	private int id;
	private String isbn;
	private String title;
	private String author;
	private double price;
	
	public Connection  getConnection(){
		// code to get jdbc connection..
		return null;
	}

	public SessionFactory  getFactory(){
		// code to get jdbc connection..
		return null;
	}
	public void addBook(Book book)throws SQLException{
		System.out.println("adding book to db using jdbc..");
	}
       public void addBookUsingHibernate(Book book)throws HibernateException{
		System.out.println("adding book to db using hibernate....");
	}
}






public interface BookDao {
		public List<Book> getAllBooks();
		public Book getBookById(int bookId);
		public void addBook(Book book);
		public void updateBook(Book book);
		public void removeBook(int bookId);
}






mysql -u root -p
use  d_jug;

create table Book (id integer not null auto_increment, author varchar(255), isbn varchar(255), price double precision not null, title varchar(255), primary key (id));

insert into Book (author, isbn, price, title) values ('raj', 'abc121', 4455.8, 'java head first');



con=DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/d_jug","root","root");
			stmt=con.prepareStatement("insert into Book (author, isbn, price, title) values (?, ?, ?, ?)");
			stmt.setInt(1, "raja");
			stmt.setString(2, "abc121");
			stmt.setDouble(3, 3333.6);
			stmt.setString(2, "java head first");
			stmt.executeUpdate();




db.properties
-------------------
driver=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/UserDB
user=root
password=root



Create an connection factory
-------------------------


package com.daniel.util;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.Properties;

public class DbUtil {

    private static Connection connection = null;

    public static Connection getConnection() {
        if (connection != null)
            return connection;
        else {
            try {
                Properties prop = new Properties();

                InputStream inputStream = DbUtil.class.getClassLoader().getResourceAsStream("db.properties");

                prop.load(inputStream);
                String driver = prop.getProperty("driver");
                String url = prop.getProperty("url");
                String user = prop.getProperty("user");
                String password = prop.getProperty("password");
                Class.forName(driver);
                connection = DriverManager.getConnection(url, user, password);
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            } catch (SQLException e) {
                e.printStackTrace();
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return connection;
        }

    }
}



GOF Pattern categories
---------------------------------
  ==> GOF, 23 patterns
   ==> Classification patterns: 

	Creational
	Structural
	Behavioral



Creational Pattern
-------------------

	==> What is the best way to create object?

	==> Creational Pattern
		=> Singleton
		=> Factory
		=> Abstract Factory
		=> Builder
		=> Prototype

structural patterns 
--------------------

	==> Structural Patterns describe how objects and 
		classes can be combined to form larger structures

	==> class patterns vs object patterns

	==> The difference between class patterns and object patterns is that 
		class patterns describe abstraction with the help of inheritance
		and how it can be used to provide more useful program interface. 

	==> Object patterns, on other hand, describe how objects can
		 be associated and composed to form larger, more complex structures

	
	==> structural patterns 

		=> Adapter Pattern
		=> Decorator Pattern :io
		=> Facade Pattern 
		=> Proxy Pattern



Behavioral Patterns
------------------

	==> Behavioural patterns are those which are concerned with 
		interactions between the objects.

	==> The interactions between the objects should be such that they 
	  are talking to each other and still are loosely coupled. 


	==> The loose coupling is the key to n-tier architectures. 
		In this, the implementation and the client should be loosely 
		coupled in order to avoid hard-coding and dependencies.

	==> Behavioral Patterns
		=> Strategy Pattern
		=> Chain of Responsibility Pattern
		=> Iterator Pattern
		=> Observer Pattern 
		=> Template Pattern



	Singleton Pattern
	===================

	" one object per application" ex logging , db connection etc

	=> lazy vs eager
	=> threading issue, double locking
	=> What if clonned
	=> What if deserilized?
	=> What if used java reflection?
	=> what if 2 class loader load that class twice
	=> best practices, effective java
	=> using enum

	Attempt 1:

	class SingletonObject {

		private static SingletonObject singletonObject;

		private SingletonObject() {}

		public static SingletonObject getSingletonObject() {
			if (singletonObject == null) {
				singletonObject = new SingletonObject();
			}
			return singletonObject;
		}

	}

	Attempt 2: What about race condition?

	
	class SingletonObject  {

		private static SingletonObject singletonObject;

		private SingletonObject() {}

		public static synchronized SingletonObject getSingletonObject() {
			if (singletonObject == null) {
				singletonObject = new SingletonObject();
			}
			return singletonObject;
		}

	}

	Attempt 3: What if somebody make clone of Singleton object?

	
	class SingletonObject  implements Cloneable {

		private static SingletonObject singletonObject;

		private SingletonObject() {}

		public static synchronized SingletonObject getSingletonObject() {
			if (singletonObject == null) {
				singletonObject = new SingletonObject();
			}
			return singletonObject;
		}

		public Object clone() throws CloneNotSupportedException {
			throw new CloneNotSupportedException();
		}

	}



	Attempt 4: Double locking
		This optimization consist in checking in an unsynchronized block if
		 the object is null and if not to check again and create it in an syncronized block. 
		This is called double locking mechanism
	
	class SingletonObject  implements Cloneable {

		private static SingletonObject singletonObject;

		private SingletonObject() {}

		public static  SingletonObject getSingletonObject() {

			if (singletonObject == null){
			synchronized(SingletonObject.class)
			{
				if (singletonObject== null)
				{
					System.out.println("getInstance(): First time getInstance was invoked!");
					instance = new Singleton();
				}
			}            
		}

		return singletonObject;


		}

		public Object clone() throws CloneNotSupportedException {
			throw new CloneNotSupportedException();
		}

	}

	What if used reflection to create an object:
	--------------------------------------------
		Constructor[] constructors=SingletonObject.class.getDeclaredConstructors();
		constructors[0].setAccessible(true);
		SingletonObject s2=(SingletonObject) constructors[0].newInstance();


	What if serialization is done?

	protected Object readResolve() {
   		 return getInstance();
	}



	Prototype Pattern (best practics for creating clone)
	===================================================

		=> About creating clone of an object

		=> Why clonning? cloning of an object to avoid creation

		=> If the cost of creating a new object is large and creation 
			is resource intensive, we clone the object

		=> We use the interface Cloneable and call its method clone() to clone the 			
			object

		=> Deep copy vs shallow copy

		=> Shallow copying generally means copying only one level of an object,
		 while deep copying generally means copying more than one level


	Ex:

	
//about what is the best practice to create clone of an object?

  class Employee implements Cloneable {
	private Integer id;
	private String name;
	private Date hireDay;//mutable

	public Employee(Integer id, String name, Date date) {
		super();
		this.id = id;
		this.name = name;
		this.hireDay=date;
	}

	@Override
	public String toString() {
		return "Employee [id=" + id + ", name=" + name + ", hireDay=" + hireDay
				+ "]";
	}

	@Override
	public Object clone() throws CloneNotSupportedException {
		 // call Object.clone()
		 Employee cloned = (Employee) super.clone();

		// clone mutable fields
		 cloned.hireDay = (Date) hireDay.clone();

		 return cloned;
	}

	public void changeHireDay(int year, int month, int day){
		 hireDay.setDate(day);
	}

	public Integer getId() {
		return id;
	}

	public void setId(Integer id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Date getHireDay() {
		return hireDay;
	}

	public void setHireDay(Date hireDay) {
		this.hireDay = hireDay;
	}
	
	
}

public class Demo {
	public static void main(String[] args) throws CloneNotSupportedException {
			Date date=new GregorianCalendar(2001, 11, 22).getTime();
		
		Employee employee1 = new Employee(33, "raja", date);
	
		Employee employee2 = (Employee) employee1.clone();
	
		System.out.println(employee1);
		System.out.println(employee2);
		
		System.out.println("After changing............");
		employee1.changeHireDay(2011, 11, 11);
		employee1.setName("amit");
		System.out.println(employee1);
		System.out.println(employee2);

	}

}


Builder Pattern
================

	==> The Builder pattern can be used to ease the construction 
	   of a complex object from simple objects

	public class Food {
		private String name;
		private int unit;
		private int vitC;
		private int vitA;
		private int vitB12;
		private int vitB5;
		private int vitD;

		//
		
	}
		
	public class FoodBuilder {
	
		private String name;
		private int unit;
		private int vitC=100;
		private int vitA=100;
		private int vitB12=100;
		private int vitB5=100;
		private int vitD=5000;
		public FoodBuilder(String name, int unit) {
			super();
			this.name = name;
			this.unit = unit;
		}
		
		
		public Food build(){
			return new Food(name, unit, vitC, vitA, vitB12, vitB5, vitD);
		}
	
	
		public FoodBuilder setName(String name) {
			this.name = name;
			return this;
		}

	}

	public class DemoBuilder {
	
		public static void main(String[] args) {
			Food food=new FoodBuilder("apple", 400).setVitA(5000).build();
		}
	}

	
	Factory Method
	===============
	Defind an interface for creating an object, but let subclass decide which object to instantiate, 
		Factory method let a class defer instantiation to subclass using inheritance

	=> provide an interface for creating an oblject here do not consider the word interface as java interface. 
	It simply mean to provides a contract / method to create an object

	=> let the subclass decide what exact object ot instantiate- This pattern involve "inheritance"


	=>Calendar calendar = Calendar.getInstance();
		System.out.println(calendar);

	=> createStatement() of java.sql.Connection interface

	=> createSocket() of java.rmi.server.RmiClientSocketFactory



db.properties
-------------------

driver=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/bookapp
user=root
password=root




Create an connection factory
-------------------------


import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.Properties;

public class ConnectionFactory{

    private static Connection connection = null;

    public static Connection getConnection() {
        if (connection != null)
            return connection;
        else {
            try {
                Properties prop = new Properties();
		//FileInputStream in = new FileInputStream
                InputStream inputStream = ConnectionFactory.class.getClassLoader().getResourceAsStream("db.properties");

                prop.load(inputStream);
                String driver = prop.getProperty("driver");
                String url = prop.getProperty("url");
                String user = prop.getProperty("user");
                String password = prop.getProperty("password");
                Class.forName(driver);
                connection = DriverManager.getConnection(url, user, password);
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            } catch (SQLException e) {
                e.printStackTrace();
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return connection;
        }

    }
}




	Factory Method pattern
	========================
	=> Defind an interface for creating an object, but let subclass decide which object to instantiate, 
		Factory method let a class defer instantiation to subclass using inheritance.

	Implementation:
	---------------
	=> provide an interface for creating an oblject here do not consider the word interface as java interface. 
	It simply mean to provides a contract / method to create an object

	=> let the subclass decide what exact object ot instantiate- This pattern involve "inheritance"

	=> let we write an batch file processor
	 steps: 1. open an file
		2. choose a parser
		3. use parser to get List of records
		4. process record ie put to db
		5. write summery
		6. close file


		File f=openFile(fileName);
		

	Attempt 1: Writing batch process for processing text file
	---------------------------------------------------------
	
	public class BatchProcessor {
	
		public void processBatch(String fileName) {
			File file = openFile();
			TextParser parser = new TextParser(file);
			List<Record> records = parser.parse();
			processorRecords(records);
			writeSummray();
			closeFile();
	
		}
	
		private void processorRecords(List<Record> records) {
			System.out.println("processing each record to db");
		}
	
		private void writeSummray() {
			System.out.println("writing summery report");
		}
	
		private void closeFile() {
			System.out.println("closing the file...");
		}
	
		private File openFile() {
			System.out.println("open the file...");
			return null;
		}
	}


	public class TextParser {
	
		public TextParser(File file) {
			System.out.println("creating text parser...");
		}
	
		public List<Record> parse() {
			System.out.println("creating record list using text parser...");
			return null;
		}
	
	}


	public class Record {}


	public class Main {
		public static void main(String[] args) {
			
			BatchProcessor batchProcessor=new BatchProcessor();
			batchProcessor.processBatch("foo");		
		}
	}


	Attempt 2: Writing batch process for processing cvs file too...
	---------------------------------------------------------
	
	To cater the requirment i will create an interface:
	
	public interface Parser {
		public abstract List<Record> parse();
	}


	public class CVSParser implements Parser {
		public CVSParser(File file) {
			System.out.println("creating cvs parser...");
		}
	
		@Override
		public List<Record> parse() {
			System.out.println("creating record list using cvs parser...");
			return null;
		}
	
	}


	public class TextParser implements Parser {
		public TextParser(File file) {
			System.out.println("creating text parser...");
		}
	
		@Override
		public List<Record> parse() {
			System.out.println("creating record list using text parser...");
			return null;
		}
	}


	Now  i need to change BatchProcessor class and need to pass choice of parser: 


	public void processBatch(String fileName, String format) {
		Parser parser=null;
		File file = openFile();
		if(format.equals("text"))
			parser = new TextParser(file);
		else if(format.equals("cvs"))
			parser=new CVSParser(file);
			
		List<Record> records = parser.parse();
		processorRecords(records);
		writeSummray();
		closeFile();

	}


	Attempt 3: Writing batch process for processing xml file too...
	---------------------------------------------------------
		public class XmlParser implements Parser {
		
		public XmlParser(File file) {
			System.out.println("creating xml parser...");
		}
	
		@Override
		public List<Record> parse() {
			System.out.println("creating record list using xml parser...");
			return null;
		}
	
	}



	Now again i need to change BatchProcessor class and need to pass choice of parser: 


			public void processBatch(String fileName, String formete) {
			Parser parser=null;
			File file = openFile();
			if(formete.equals("text"))
				parser = new TextParser(file);
			else if(formete.equals("cvs"))
				parser=new CVSParser(file);
				
			List<Record> records = parser.parse();
			processorRecords(records);
			writeSummray();
			closeFile();
	
		}


	=> clear voilation of OCP
	=> We are supposed to change BatchProcessor every now and then, can not do in case of api design 
	=> voilation of Dependency inversion: depend on abstraction

	Solution:
	---------
		=> this is not acceptable code:
		   ----------------------------
			if(formete.equals("text"))
				parser = new TextParser(file);
			else if(formete.equals("cvs"))
				parser=new CVSParser(file);
			else if(formete.equals("xml"))
				parser=new XmlParser(file);



		=> refactoring code:
		--------------------


	public void processBatch(String fileName, String formete) {
		Parser parser = null;
		File file = openFile();

		parser = createParser(file);
		List<Record> records = parser.parse();
		processorRecords(records);
		writeSummray();
		closeFile();

	}
	 abstract Parser createParser(File file);


		=> now its works as a framework for batch processing
		and we never have to change BatchProcessor for changing parser approach


	
	BatchProcessor batchProcessor=new TextBatchProcessor();
	batchProcessor.processBatch("foo","xml");
			
	https://stackoverflow.com/questions/13029261/
	design-patterns-factory-vs-factory-method-vs-abstract-factory/35851402#35851402






structural patterns 
==========================
		=> Adapter
		=> Decorator
		=> Facade Pattern
		=> Bridge
		=> Composite
		=> Flyweight
		=> Proxy

Adapter Pattern
================
	==> It helps in integrating two modules with different incompatible interfaces. 
	==> The Adapter pattern is used so that two unrelated interfaces can work together
	==> The joining between them is called an Adapter. 
	==> This is something like we convert interface of one class into interface expected by the client. 
	==>  Way to implement adaper
		=> Using inheritance: A class adapter 
		=> User composition: An object adapter

	Use cases:
	----------
	1. Most important task of an Adapter is to transfer data between applications or modules.
	2. Very common task is to parse the information from one kind to the other
	3. Convert from one type to the other
	4. Some times adapters even validate the data so that right data flows into the application 
	from external applications.

	=> Having adapters help in keeping the conversion code separate so that the parsing functionality
	 is not leaking into the core modules of our application.

	=> Another important advantage of having an adapter is that when there is a 
	change in outside interface, our core modules does not get affected. 
	Only adapters need to be modified. So, this helps in restricting the changes to 
	 adapter module alone and rest of application does not get affected. 




	Convert the interface of a class into another interface clients expect. 
	Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.


	Adapter Pattern hello world:
	----------------------------
	public class RoundPeg {
		public void insertTohole(String str) {
			System.out.println("roundpeg insertTohole(): " + str);
		}
	}

	public class SquarePeg {
		public void insert(String str) {
			System.out.println("SquarePeg insert(): " + str);
		}
	}



	// adaptoing roundpeg to square pag
	public class PegAdaptor extends SquarePeg  {
	
		private RoundPeg peg;
	
		public PegAdaptor(RoundPeg peg) {
			super();
			this.peg = peg;
		}
		
		public void insert(String str) {
			peg.insertTohole(str);
		}
	}



//adaptoing roundpeg to square pag
public class Demo {

	public static void main(String[] args) {
		
		RoundPeg peg=new RoundPeg();
		PegAdaptor adpt=new PegAdaptor(peg);
		adpt.insert("hello");
	}
}

Examples:
---------
java.util.Arrays#asList()
java.io.InputStreamReader(InputStream) (returns a Reader)
java.io.OutputStreamWriter(OutputStream) (returns a Writer)




decorator pattern / wrapper pattern 
=================================

	=> Decorator pattern helpful in adding behaviour to objects statically or dynamically.

	=> Decorator pattern helps in extending the functionality of the objects without
	 effecting the behaviour of other objects.

	=> Decorator adhering to the design principle of Open for extension and closed for modification

	=> In the Decorator pattern, a decorator object is wrapped around the original object

 	=> This is typically achieved having the original object as a member
		 of the decorator, with the decorator forwarding the 
		requests to the original object and also implementing the new functionality

	==> The decorator must conform to the interface of the original object
		 (the object being decorated) 


	=> Simple greet application:
	---------------------------------

	Car-> BasicCar-> SportCar->SuperSportCar
		
	
	interface Car{
		public String assemble();
	}
	class BasicCar implements Car{
	
		@Override
		public String assemble() {
			return "basic car";
		}
		
	}
	abstract class CarDecorator implements Car{
		private Car car;
		public CarDecorator(Car car) {
			this.car = car;
		}
		
		@Override
		public String assemble() {
			return car.assemble();
		}
	}
	class SportCar extends CarDecorator{
	
		public SportCar(Car car) {
			super(car);
		}
	
		@Override
		public String assemble() {
			return super.assemble()+" with sport feature";
		}
	}
	
	class SuperSportCar extends CarDecorator{
	
		public SuperSportCar(Car car) {
			super(car);
		}
	
		@Override
		public String assemble() {
			return super.assemble()+" with extra super sport feature";
		}
	}



SuperSportCar sportCar=new SuperSportCar(new SportCar(new BasicCar()));

proxy design pattern:
------------------
	=> Provide a surrogate or placeholder for another object to control access to it

	public class Magician {
	
		public void doMagic(){
			System.out.println("abra ka dabra...");
		}
	}


	public class AudianceAdvice {
	
		public void clapping(){
			System.out.println("maza aa gaya...");
		}
	}



	@Aspect
	@Component
	public class AudianceAdvice {
		@Before("execution(public void doMagic())")
		public void clapping(){
			System.out.println("maza aa gaya...");
		}
	}


Example RMI:
=============



RMI server
-------------

public interface AtmCard extends Remote {

	public boolean isValid(String card)throws RemoteException;
}





public class AtomCardImp extends UnicastRemoteObject implements AtmCard,
		Serializable {

	protected AtomCardImp() throws RemoteException {
		super();
	}

	@Override
	public boolean isValid(String card) throws RemoteException {
		Integer val = Integer.parseInt(card);
		if (val % 2 == 0)
			return false;
		else
			return true;
	}

}



public class Server {
	public static void main(String[] args) throws RemoteException, AlreadyBoundException {
		AtomCardImp obj=new AtomCardImp();
		
		Registry registry=LocateRegistry.createRegistry(222);//pass port no
		registry.bind("obj", obj);
		System.out.println("service is bound!");
		
	}

}



RMI Client
-------------


public interface AtmCard extends Remote {

	public boolean isValid(String card)throws RemoteException;
}



public class RMIClient {
	public static void main(String[] args) throws RemoteException, NotBoundException {
		Registry registry=LocateRegistry.getRegistry("localhost", 222);
		AtmCard card=(AtmCard) registry.lookup("obj");
		
		System.out.println(card.isValid("121"));
		
	}

}



	 


======================
 Behavioral Patterns
======================

		Iterator
		Observer
		Strategy
		Chain of Responsibility
		Template design pattern
		Command
		Interpreter
		Mediator
		Memento
		


	Iterator design pattern:
	------------------------
	=> iterator pattern allows for the traversal through the elements
	 in a grouping of objects via a standardized interface. 

	=> An Iterator interface defines the actions that can be performed.

	=>  These actions include being able to traverse the objects and also obtain the objects


	Example : write our own iterator by implementing java.util.Iterator
		 hasNext(), next(), and remove() methods



public class Item {

	String name;
	float price;

	public Item(String name, float price) {
		this.name = name;
		this.price = price;
	}

	public String toString() {
		return name + ": $" + price;
	}
}



public class Menu {

	List<Item> menuItems;

	public Menu() {
		menuItems = new ArrayList<Item>();
	}

	public void addItem(Item item) {
		menuItems.add(item);
	}

	public Iterator<Item> iterator() {
		return new MenuIterator();
	}

	class MenuIterator implements Iterator<Item> {
		int currentIndex = 0;

		@Override
		public boolean hasNext() {
			if (currentIndex >= menuItems.size()) {
				return false;
			} else {
				return true;
			}
		}

		@Override
		public Item next() {
			return menuItems.get(currentIndex++);
		}

		@Override
		public void remove() {
			menuItems.remove(--currentIndex);
		}

	}

}


public class Demo {

	public static void main(String[] args) {

		Item i1 = new Item("mouse", 7.50f);
		Item i2 = new Item("laptop", 6.00f);
		Item i3 = new Item("DVD", 6.50f);

		Menu menu = new Menu();
		menu.addItem(i1);
		menu.addItem(i2);
		menu.addItem(i3);

		System.out.println("Displaying Menu:");
		Iterator<Item> iterator = menu.iterator();
		while (iterator.hasNext()) {
			Item item = iterator.next();
			System.out.println(item);
		}

		System.out.println("\nRemoving last item returned");
		iterator.remove();

		System.out.println("\nDisplaying Menu:");
		iterator = menu.iterator();
		while (iterator.hasNext()) {
			Item item = iterator.next();
			System.out.println(item);
		}

	}

}


Observer design pattern:
========================

	=> Observer pattern in java is one of the most important design patterns. 
	=> The concept behind the Observer design pattern is the basis for PubSub, event and non blocking based systems
	
	

		//observable (news paper wala)
		public class MySubject extends Observable {
			private String name;
			private float price;
		
			public MySubject(String name, float price) {
				this.name = name;
				this.price = price;
			}
		
			public String getName() {
				return name;
			}
		
			public void setName(String name) {
				this.name = name;
			}
		
			public float getPrice() {
				return price;
			}
		
			public void setPrice(float price) {
				this.price = price;
				setChanged();
				notifyObservers(new Float(price));
			}
		
		}
		
		


			
			public class MyObserver  implements Observer{
				private float price;
				
				@Override
				public void update(Observable o, Object a) {
					
					price=(float) a;
					
					System.out.println("price observed : price changed to :"+price);
				}
			
			}





		MySubject subject=new MySubject("rice", 55);
		MyObserver o=new MyObserver();
		
		subject.addObserver(o);
		
		subject.setPrice(88);
		subject.setPrice(99);




Chain of Responsibility
-----------------------

	=> used to achieve loose coupling in software design where a request 
	from client is passed to a chain of objects to process them. 

	=>Then the object in the chain will decide themselves who will 
	be processing the request and whether the request is 
	required to be sent to the next object in the chain or not.

	=> ex:  try-catch block

	=> Ex: ATM Dispense machine, 50$, 20$, 10$ etc




public class Currency {

	private int amount;
	
	public Currency(int amt){
		this.amount=amt;
	}
	
	public int getAmount(){
		return this.amount;
	}
}



public interface DispenseChain {

	void setNextChain(DispenseChain nextChain);
	
	void dispense(Currency cur);
}




public class Dollar50Dispenser implements DispenseChain {

	private DispenseChain chain;
	
	@Override
	public void setNextChain(DispenseChain nextChain) {
		this.chain=nextChain;
	}

	@Override
	public void dispense(Currency cur) {
		if(cur.getAmount() >= 50){
			int num = cur.getAmount()/50;
			int remainder = cur.getAmount() % 50;
			System.out.println("Dispensing "+num+" 50$ note");
			if(remainder !=0) this.chain.dispense(new Currency(remainder));
		}else{
			this.chain.dispense(cur);
		}
	}

}





public class Dollar20Dispenser implements DispenseChain{

	private DispenseChain chain;
	
	@Override
	public void setNextChain(DispenseChain nextChain) {
		this.chain=nextChain;
	}

	@Override
	public void dispense(Currency cur) {
		if(cur.getAmount() >= 20){
			int num = cur.getAmount()/20;
			int remainder = cur.getAmount() % 20;
			System.out.println("Dispensing "+num+" 20$ note");
			if(remainder !=0) this.chain.dispense(new Currency(remainder));
		}else{
			this.chain.dispense(cur);
		}
	}

}




public class Dollar10Dispenser implements DispenseChain {

	private DispenseChain chain;
	
	@Override
	public void setNextChain(DispenseChain nextChain) {
		this.chain=nextChain;
	}

	@Override
	public void dispense(Currency cur) {
		if(cur.getAmount() >= 10){
			int num = cur.getAmount()/10;
			int remainder = cur.getAmount() % 10;
			System.out.println("Dispensing "+num+" 10$ note");
			if(remainder !=0) this.chain.dispense(new Currency(remainder));
		}else{
			this.chain.dispense(cur);
		}
	}

}



//  Creating the Chain
======================
public class ATMDispenseChain {

	private DispenseChain c1;

	public ATMDispenseChain() {
		// initialize the chain
		this.c1 = new Dollar50Dispenser();
		DispenseChain c2 = new Dollar20Dispenser();
		DispenseChain c3 = new Dollar10Dispenser();

		// set the chain of responsibility
		c1.setNextChain(c2);
		c2.setNextChain(c3);
	}

	public static void main(String[] args) {
		ATMDispenseChain atmDispenser = new ATMDispenseChain();
		while (true) {
			int amount = 0;
			System.out.println("Enter amount to dispense");
			Scanner input = new Scanner(System.in);
			amount = input.nextInt();
			if (amount % 10 != 0) {
				System.out.println("Amount should be in multiple of 10s.");
				return;
			}
			// process the request
			atmDispenser.c1.dispense(new Currency(amount));
		}

	}

}


template design pattern:
-------------------------
http://www.journaldev.com/1763/template-method-design-pattern-in-java


	=> Template Method is a behavioral design pattern. 

	=> Template Method design pattern is used to create a method stub and 		
		deferring some of the steps of implementation to the subclasses.

	=> Template method defines the steps to execute an algorithm and it
	 can provide default implementation that might be common for all or some of 		
		the subclasses.

	=> suppose we want to provide an algorithm to build a house. 
	The steps need to be performed to build a house are 
	 building foundation, building pillars, building walls and windows.

	=>  The important point is that the we cant change the order of execution
	 because we can't build windows before building the foundation.

	=> So in this case we can create a template method that will use different methods to build the house



public abstract class HouseTemplate {

	//template method, final so subclasses can't override
	public final void buildHouse(){
		buildFoundation();
		buildPillars();
		buildWalls();
		buildWindows();
		System.out.println("House is built.");
	}

	//default implementation
	private void buildWindows() {
		System.out.println("Building Glass Windows");
	}

	//methods to be implemented by subclasses
	public abstract void buildWalls();
	public abstract void buildPillars();

	private void buildFoundation() {
		System.out.println("Building foundation with cement,iron rods and sand");
	}
}



public class WoodenHouse extends HouseTemplate {

	@Override
	public void buildWalls() {
		System.out.println("Building Wooden Walls");
	}

	@Override
	public void buildPillars() {
		System.out.println("Building Pillars with Wood coating");
	}

}




public class GlassHouse extends HouseTemplate {

	@Override
	public void buildWalls() {
		System.out.println("Building Glass Walls");
	}

	@Override
	public void buildPillars() {
		System.out.println("Building Pillars with glass coating");
	}

}



		HouseTemplate houseType = new WoodenHouse();
		
		//using template method
		houseType.buildHouse();
		System.out.println("************");
		
		houseType = new GlassHouse();
		
		houseType.buildHouse();



	Example in jdk:
	-----------------
	=> All non-abstract methods of java.io.InputStream, java.io.OutputStream, java.io.Reader and java.io.Writer.

	=> All non-abstract methods of java.util.AbstractList, java.util.AbstractSet and java.util.AbstractMap.




Strategy Pattern 
================
	=>The strategy pattern is intended to provide a means to define a family of algorithms, encapsulate each one '
	as an object, and make them interchangeable select algo at run time convert IS-A to HAS-A



command design pattern:
=======================
	=> command design pattern is used to implement loose coupling in a request-response model
	=> In command pattern, the request is send to the invoker and invoker
		 pass it to the encapsulated command object.
	=> Command object passes the request to the appropriate method of Receiver to perform the specific action.

	http://www.journaldev.com/1624/command-design-pattern


Interpreter Design Pattern
==========================

	=> Interpreter pattern is one of the behavioral design pattern and 
	is used to defines a grammatical representation for a language and provides 
	an interpreter to deal with this grammar. 

	The best example of this pattern is java compiler that interprets the java 
	source code into byte code that is understandable by JVM. Google Translator


	http://www.journaldev.com/1635/interpreter-design-pattern-in-java-example-tutorial




memento design pattern
=======================
	=> Memento design pattern is used when we want to save the state of an object 
	so that we can restore later on. Memento pattern is used to implement
	 this in such a way that the saved state data of the object is not accessible outside of the object, 
	this protects the integrity of saved state data.


	=> Originator is the object whose state needs to be saved and restored and it uses an inner class to save the
	 state of Object. The inner class is called Memento and it’s private,
	 so that it can’t be accessed from other objects.

	=> Caretaker is the helper class that is responsible for storing and restoring 
	the Originator’s state through Memento object. Since Memento is private to Originator, 
	Caretaker can’t access it and it’s stored as an Object within the caretaker.

	=> Example text editors where we can save it’s data anytime and use undo to restore it to previous saved state

http://www.journaldev.com/1734/memento-design-pattern-java





Mediator
============
	=> Allows loose coupling by encapsulating the way disparate sets of objects 
	interact and communicate with each other.

	=>  Allows for the actions of each object set to vary independently of one another.

	=> Mediator design pattern is very helpful in an enterprise application where 
	multiple objects are interacting with each other. 

	=> If the objects interact with each other directly, the system components are tightly-coupled 
	with each other that makes higher maintainability cost and not hard to extend. 

	=> Mediator pattern focuses on provide a mediator between objects for communication 
	and help in implementing lose-coupling between objects.

	=> Air traffic controller is a great example of mediator pattern where the airport control room 
	works as a mediator for communication between different flights. 
	Mediator works as a router between objects and it can have it’s own logic to provide way of communication.

	=>Other example ESB bus in SOA

http://www.journaldev.com/1730/mediator-design-pattern-java





Strategy Pattern 
================
	

Strategy Pattern
-----------------
	=>The strategy pattern is intended to provide a means to define a family of algorithms,    		encapsulate each one as an object, and make them interchangeable select algo at run time 		convert IS-A to HAS-A

	=> It separate algorithms into classes that can be plugged in at runtime.
 
	=> I need to provide discount strategy for code flexibility 

	=> used when we have multiple algorithm for a specific task and client
	 decides the actual implementation to be used at runtime.


Designing shopping cart :
------------------------

class Product {
	private int id;
	private String name;
	private double price;
	private int quantity;

}


public class Cart {
	private List<Product> productList = new ArrayList<>();
	private double totalCartValue;


	public void addProduct(Product product) {
		productList.add(product);
	} 
	

	public int getProductCount(){
		return productList.size();
	}
	
	public double getTotalCartValue(){
		if(productList.size()> 0){
			for(Product p: productList){
				totalCartValue=totalCartValue+p.getPrice()*p.getQuantity();
			}
		}
			
		return totalCartValue;
	}
}



Now we need discount policy:
-----------------------------
discount can change any time...we need flexiable model

interface Discount {
	public void discount(Product product);

}

// buy 5 get 2 item free
class BuyXGetYItem implements Discount {
	private int x;
	private int y;

	public BuyXGetYItem(int x, int y) {
		this.x = x;
		this.y = y;
	}

	@Override
	public void discount(Product product) {
		if(product.getQuantity()>=x){
			product.setQuantity(product.getQuantity()+product.getQuantity());
		}
	}
}

class BuyXGetYPercentageDiscount implements Discount{
	private int x;
	private int y;

	public BuyXGetPercentageDiscount(int x, int y) {
		this.x = x;
		this.y = y;
	}

	@Override
	public void discount(Product product) {
		if(product.getQuantity()>=x){
			double reducedPrice=(product.getPrice()-product.getPrice()*y/100);
			product.setPrice(reducedPrice);
		}
	}
}






public class Cart {
	private List<Product> productList = new ArrayList<>();
	private double totalCartValue;
	private Discount discount;


	public void addProduct(Product product) {
		if(discount != null){
			discount.discount(product);//apply offer
		}
		productList.add(product);
	} 
	
	public void setDiscount(Discount discount) {
		this.discount = discount;
	}

	public int getProductCount(){
		return productList.size();
	}
	
	public double getTotalCartValue(){
		if(productList.size()> 0){
			for(Product p: productList){
				totalCartValue=totalCartValue+p.getPrice()*p.getQuantity();
			}
		}
			
		return totalCartValue;
	}
}




Selected topics:
-------------






SOLID
http://cafe.elharo.com/programming/a-square-is-not-a-rectangle/
http://www.cdf.toronto.edu/~csc207h/fall/stg/lectures/eve/w10/
http://zeroturnaround.com/rebellabs/object-oriented-design-principles-and-the-5-ways-of-creating-solid-applications/
http://www.informit.com/store/java-coding-guidelines-75-recommendations-for-reliable-9780321933157


Creational patterns:
-------------------
Singleton Pattern 
Factory Pattern 
Abstract Factory Pattern
Builder Pattern 
Prototype Pattern 


structural patterns 
--------------------
Adapter Pattern 
	http://www.journaldev.com/1487/adapter-design-pattern-in-java-example-tutorial
Composite Pattern
Proxy Pattern
	http://www.oodesign.com/proxy-pattern.html

Flyweight Pattern
	http://www.oodesign.com/flyweight-pattern.html

Facade pattern
	http://www.oodesign.com/bridge-pattern.html
Bridge Pattern
	http://www.oodesign.com/bridge-pattern.html

Decorator Pattern 


Behaviour pattern
------------------
Template Method Pattern
	http://www.oodesign.com/template-method-pattern.html

Mediator Pattern

Chain of Responsibility Pattern
	http://www.journaldev.com/1617/chain-of-responsibility-design-pattern-in-java-example-tutorial

Observer Pattern
	http://www.oodesign.com/observer-pattern.html

Strategy Pattern

Command Pattern

State Pattern

Visitor Pattern

Interpreter Pattern

Iterator Pattern

Memento Pattern

























